// Code generated by bpf2go; DO NOT EDIT.
//go:build (mips || mips64 || ppc64 || s390x) && linux

package attacher

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type TCDnsEvent struct {
	Base struct {
		Saddr       uint32
		Daddr       uint32
		IpTos       uint8
		_           [1]byte
		IpTotalLen  uint16
		IpId        uint16
		IpFragOff   uint16
		IpTtl       uint8
		IpProtocol  uint8
		IpCheck     uint16
		Sport       uint16
		Dport       uint16
		Seq         uint32
		AckSeq      uint32
		TcpFlags    uint8
		_           [1]byte
		Window      uint16
		TcpCheck    uint16
		UdpLen      uint16
		UdpCheck    uint16
		_           [6]byte
		TimestampNs uint64
		PayloadSize uint16
		_           [6]byte
	}
	DnsTransactionId uint16
	DnsQueryType     uint16
	DnsQueryName     [32]uint8
	DnsResponseCode  uint8
	IsQuery          uint8
	_                [2]byte
}

type TCHttp2Event struct {
	Base struct {
		Saddr       uint32
		Daddr       uint32
		IpTos       uint8
		_           [1]byte
		IpTotalLen  uint16
		IpId        uint16
		IpFragOff   uint16
		IpTtl       uint8
		IpProtocol  uint8
		IpCheck     uint16
		Sport       uint16
		Dport       uint16
		Seq         uint32
		AckSeq      uint32
		TcpFlags    uint8
		_           [1]byte
		Window      uint16
		TcpCheck    uint16
		UdpLen      uint16
		UdpCheck    uint16
		_           [6]byte
		TimestampNs uint64
		PayloadSize uint16
		_           [6]byte
	}
	Http2FrameLength uint32
	Http2FrameType   uint8
	Http2FrameFlags  uint8
	_                [2]byte
	Http2StreamId    uint32
	Payload          [256]uint8
	_                [4]byte
}

type TCHttpEvent struct {
	Base struct {
		Saddr       uint32
		Daddr       uint32
		IpTos       uint8
		_           [1]byte
		IpTotalLen  uint16
		IpId        uint16
		IpFragOff   uint16
		IpTtl       uint8
		IpProtocol  uint8
		IpCheck     uint16
		Sport       uint16
		Dport       uint16
		Seq         uint32
		AckSeq      uint32
		TcpFlags    uint8
		_           [1]byte
		Window      uint16
		TcpCheck    uint16
		UdpLen      uint16
		UdpCheck    uint16
		_           [6]byte
		TimestampNs uint64
		PayloadSize uint16
		_           [6]byte
	}
	HttpMethod     [8]uint8
	HttpUri        [64]uint8
	HttpStatusCode [16]uint8
	IsRequest      uint8
	_              [7]byte
}

type TCIcmpEvent struct {
	Base struct {
		Saddr       uint32
		Daddr       uint32
		IpTos       uint8
		_           [1]byte
		IpTotalLen  uint16
		IpId        uint16
		IpFragOff   uint16
		IpTtl       uint8
		IpProtocol  uint8
		IpCheck     uint16
		Sport       uint16
		Dport       uint16
		Seq         uint32
		AckSeq      uint32
		TcpFlags    uint8
		_           [1]byte
		Window      uint16
		TcpCheck    uint16
		UdpLen      uint16
		UdpCheck    uint16
		_           [6]byte
		TimestampNs uint64
		PayloadSize uint16
		_           [6]byte
	}
	IcmpId   uint16
	IcmpSeq  uint16
	IcmpType uint8
	IcmpCode uint8
	_        [2]byte
}

type TCKafkaEvent struct {
	Base struct {
		Saddr       uint32
		Daddr       uint32
		IpTos       uint8
		_           [1]byte
		IpTotalLen  uint16
		IpId        uint16
		IpFragOff   uint16
		IpTtl       uint8
		IpProtocol  uint8
		IpCheck     uint16
		Sport       uint16
		Dport       uint16
		Seq         uint32
		AckSeq      uint32
		TcpFlags    uint8
		_           [1]byte
		Window      uint16
		TcpCheck    uint16
		UdpLen      uint16
		UdpCheck    uint16
		_           [6]byte
		TimestampNs uint64
		PayloadSize uint16
		_           [6]byte
	}
	KafkaApiKey        uint16
	KafkaApiVersion    uint16
	KafkaCorrelationId uint32
	Payload            [256]uint8
}

type TCRedisEvent struct {
	Base struct {
		Saddr       uint32
		Daddr       uint32
		IpTos       uint8
		_           [1]byte
		IpTotalLen  uint16
		IpId        uint16
		IpFragOff   uint16
		IpTtl       uint8
		IpProtocol  uint8
		IpCheck     uint16
		Sport       uint16
		Dport       uint16
		Seq         uint32
		AckSeq      uint32
		TcpFlags    uint8
		_           [1]byte
		Window      uint16
		TcpCheck    uint16
		UdpLen      uint16
		UdpCheck    uint16
		_           [6]byte
		TimestampNs uint64
		PayloadSize uint16
		_           [6]byte
	}
	RedisCommandType uint8
	RedisRespType    uint8
	RedisPayload     [128]uint8
	_                [6]byte
}

// LoadTC returns the embedded CollectionSpec for TC.
func LoadTC() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_TCBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load TC: %w", err)
	}

	return spec, err
}

// LoadTCObjects loads TC and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*TCObjects
//	*TCPrograms
//	*TCMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadTCObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadTC()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// TCSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type TCSpecs struct {
	TCProgramSpecs
	TCMapSpecs
	TCVariableSpecs
}

// TCProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type TCProgramSpecs struct {
	EgressProgFunc  *ebpf.ProgramSpec `ebpf:"egress_prog_func"`
	IngressProgFunc *ebpf.ProgramSpec `ebpf:"ingress_prog_func"`
}

// TCMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type TCMapSpecs struct {
	DnsQueue         *ebpf.MapSpec `ebpf:"dns_queue"`
	Http2Queue       *ebpf.MapSpec `ebpf:"http2_queue"`
	HttpQueue        *ebpf.MapSpec `ebpf:"http_queue"`
	IcmpQueue        *ebpf.MapSpec `ebpf:"icmp_queue"`
	KafkaQueue       *ebpf.MapSpec `ebpf:"kafka_queue"`
	PayloadHeap      *ebpf.MapSpec `ebpf:"payload_heap"`
	RedisPayloadHeap *ebpf.MapSpec `ebpf:"redis_payload_heap"`
	RedisQueue       *ebpf.MapSpec `ebpf:"redis_queue"`
}

// TCVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type TCVariableSpecs struct {
	UnusedDns   *ebpf.VariableSpec `ebpf:"unused_dns"`
	UnusedHttp  *ebpf.VariableSpec `ebpf:"unused_http"`
	UnusedHttp2 *ebpf.VariableSpec `ebpf:"unused_http2"`
	UnusedIcmp  *ebpf.VariableSpec `ebpf:"unused_icmp"`
	UnusedKafka *ebpf.VariableSpec `ebpf:"unused_kafka"`
	UnusedRedis *ebpf.VariableSpec `ebpf:"unused_redis"`
}

// TCObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadTCObjects or ebpf.CollectionSpec.LoadAndAssign.
type TCObjects struct {
	TCPrograms
	TCMaps
	TCVariables
}

func (o *TCObjects) Close() error {
	return _TCClose(
		&o.TCPrograms,
		&o.TCMaps,
	)
}

// TCMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadTCObjects or ebpf.CollectionSpec.LoadAndAssign.
type TCMaps struct {
	DnsQueue         *ebpf.Map `ebpf:"dns_queue"`
	Http2Queue       *ebpf.Map `ebpf:"http2_queue"`
	HttpQueue        *ebpf.Map `ebpf:"http_queue"`
	IcmpQueue        *ebpf.Map `ebpf:"icmp_queue"`
	KafkaQueue       *ebpf.Map `ebpf:"kafka_queue"`
	PayloadHeap      *ebpf.Map `ebpf:"payload_heap"`
	RedisPayloadHeap *ebpf.Map `ebpf:"redis_payload_heap"`
	RedisQueue       *ebpf.Map `ebpf:"redis_queue"`
}

func (m *TCMaps) Close() error {
	return _TCClose(
		m.DnsQueue,
		m.Http2Queue,
		m.HttpQueue,
		m.IcmpQueue,
		m.KafkaQueue,
		m.PayloadHeap,
		m.RedisPayloadHeap,
		m.RedisQueue,
	)
}

// TCVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to LoadTCObjects or ebpf.CollectionSpec.LoadAndAssign.
type TCVariables struct {
	UnusedDns   *ebpf.Variable `ebpf:"unused_dns"`
	UnusedHttp  *ebpf.Variable `ebpf:"unused_http"`
	UnusedHttp2 *ebpf.Variable `ebpf:"unused_http2"`
	UnusedIcmp  *ebpf.Variable `ebpf:"unused_icmp"`
	UnusedKafka *ebpf.Variable `ebpf:"unused_kafka"`
	UnusedRedis *ebpf.Variable `ebpf:"unused_redis"`
}

// TCPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadTCObjects or ebpf.CollectionSpec.LoadAndAssign.
type TCPrograms struct {
	EgressProgFunc  *ebpf.Program `ebpf:"egress_prog_func"`
	IngressProgFunc *ebpf.Program `ebpf:"ingress_prog_func"`
}

func (p *TCPrograms) Close() error {
	return _TCClose(
		p.EgressProgFunc,
		p.IngressProgFunc,
	)
}

func _TCClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed tc_bpfeb.o
var _TCBytes []byte
